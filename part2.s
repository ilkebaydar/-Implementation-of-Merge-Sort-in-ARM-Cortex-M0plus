        AREA    MergeSort_M0, CODE, READONLY
        THUMB
        ENTRY
        EXPORT  main
        EXPORT  my_MergeSort
        EXPORT  my_Merge

main    PROC
		; LOAD VALUES 13,27,10,7,22,56,28,2 TO SORT
		MOVS R0, #13
		MOVS R1, #27
		MOVS R2, #10
		MOVS R3, #7
		MOVS R4, #22
		MOVS R5, #56
		MOVS R6, #28
		MOVS R7, #2
		
		PUSH {R0-R7} ;PUSH R0-R7 (USORTED ARRAY) INTO STACK. SP AT R0
		MOV R7, SP ; COPY SP TO R7= BASE ADDRESS
		MOVS R0, #0 ;INIT LEFT=0
		MOVS R1, #7 ;INIT RIGHT=7 

		BL my_MergeSort ;CALL MERGESORT FUNC
		
		POP {R0-R7} ;POP R0-R7 TO RESTORE SORTED VALUES
		
stop    B       stop             ; put breakpoint here to work 
        ENDP

my_MergeSort PROC
		PUSH {R3-R6, LR} ;SAVE R3-R6 TO WORK CONVENIENTLY AND LR ON STACK
		
		CMP R0, R1 ;CHECK LEFT AND RIGHT INDICES
		BGE ExitSort ;IF LEFT >= RIGHT, RETURN
		
		;CALCULATE MID
		ADDS R2, R0, R1 ;R2 =LEFT+RIGHT
		LSRS R2, R2, #1 ;R2=R2/2, NOW R2=MID
		
		MOV R3, R0 ;R3 HOLDS LEFT
		MOV R4, R1 ;R4 HOLDS RIGHT
		MOV R5, R2 ;R5 HOLDS MID
		
		;LEFT TO MID PART
		MOV R1, R5 ;SET RIGHT = MID
		BL my_MergeSort ;CALL my_MergeSort RECURSIVELY
		;MID+1 TO RIGHT PART
		MOV R0, R5 ;RESTORE MID TO R0
		ADDS R0, R0, #1 ; MID = MID+1
		MOV R1, R4 ;RESTORE RIGHT TO R1
		BL my_MergeSort ;CALL my_MergeSort RECURSIVELY
		
		;MERGE PART
		MOV R0, R3 ;RESTORE LEFT
		MOV R1, R4 ;RESTORE RIGHT
		MOV R2, R5 ;RESTORE MID
		BL my_Merge ;CALL MERGE FUNCTION TO COMBINE TWO SORTED PART
	
ExitSort 
		POP {R3-R6, PC} ;RESTORE REGS AND RETURN
		
		ENDP
					
my_Merge PROC
		PUSH {R4-R7, LR} ;SAVE R4-R7 AND LR INTO STACK
		;FOR USING R8 AND R9 CONVENIENTLY FOR THIS IMPLEMENTATION, PRESERVE THEIR VALUES IN STACK
		MOV R4, R8 ;MOVE R8 TO R4
		MOV R5, R9 ;MOVE R9 TO R5
		PUSH {R4,R5} ;PUSH ORIGINAL R8, R9 TO STACK
		
		;CALCULATE ADDR OF ARRAY[MID]
		LSLS R3, R2, #2 ;OFFSET =MID*4
		ADD R3, R3, R7 ;ADDR=BASE ADDR+OFFSET
		MOV R8, R3 ;STORE LEFT LIMIT ADDR IN R8
		
		;CALCULATE ADDR OF ARRAY[RIGHT]
		LSLS R3, R1, #2 ;OFFSET =RIGHT*4
		ADD R3, R3, R7 ;ADDR=BASE ADDR+OFFSET
		MOV R9, R3 ;STOR RIGHT LIMIT IN R9
		
		;CALSCULATE POINTER FOR ARRAY[LEFT]
		LSLS R5, R0, #2 ; OFFSET=LEFT*4
		ADD R5, R5, R7 ; NOW R5 IS POINTER FOR ARRAY[LEFT]
		
		;CALSCULATE POINTER FOR ARRAY[MID+1]
		ADDS R6, R2, #1 ;R6=MID+1
		LSLS R6, R6, #2 ;OFFSET=(MID+1)*4
		ADD R6, R6, R7 ;NOW R6 IS POINTER DOR ARRAY[MID+1]
		
		;ALLOCATE TEMP_ARRAY AREA ON STACK
		SUB SP, SP, #32 ;FOR 8 INT=32 BYTE AREA REQUIRED
		MOV R4, SP ;R4 HOLDS TEMP_ARRAY[0]

MergeLoop
		MOV R3, R8 ;MOVE LEFT LIMIT TO R3 FOR COMPARISON
		CMP R5, R3 ;COMPARE LEFT LIMIT VS CURRENT
		BGT CopyRight ; IF LEFT IS EMPTY, COPY RIGHT DIRECTLY
		
		MOV R3, R9 ;MOVE RIGHT LIMIT TO R3 FOR COMPARISON
		CMP R6, R3 ;COMPARE RIGHT LIMIT VS CURRENT
		BGT CopyLeft ; IF RIGHT IS EMPTY, COPY LEFT DIRECTLY
		
		LDR R0, [R5, #0] ;LOAD VALUE FROM LEFT PTR POINTS TO
		LDR R1, [R6, #0] ;LOAD VALUE FROM RIGHT PTR POINTS TO
		
		CMP R0, R1 ;COMPARE VALUE LEFT VS VALUE RIGHT
		BLE PickLeft ;IF VALUE LEFT <= VALUE RIGHT THEN PICK LEFT FOR ASCENDING ORDER ARRAY
		
		;ELSE PICK RIGHT
		STR R1, [R4, #0] ;STORE VALUE RIGHT INTO R1
		ADDS R4, R4, #4 ;INCREMENT TEMP_ARRAY PTR
		ADDS R6, R6, #4 ;INCREMENT RIGHT PTR
		B MergeLoop ;CONTINUE LOOP
		
PickLeft
		STR R0, [R4,#0] ;STORE VALUE LEFT IN [R4]
		ADDS R4, R4, #4 ; INCREMENT TEMP_ARRAY PTR
		ADDS R5, R5, #4 ;INCREMENT LEFT PTR
		B MergeLoop ;CONTINUE LOOP
		
CopyLeft
		MOV R3, R8 ;LOAD LEFT LIMIT
		CMP R5, R3 ;COMPARE LEFT PTR VS LEFT LIMIT
		BGT WriteBack ;IF LEFT PTR > LEFT LIMIT, GO TO WRITE BACK FROM TEMP TO MAIN ARRAY
		
		LDR R0, [R5, #0] ;LOAD VALUE FROM LEFT PTR
		STR R0, [R4, #0] ;STORE VALUE TO TEMP_ARRAY
		ADDS R5, R5, #4 ;INCREMENT LEFT PTR
		ADDS R4, R4, #4 ;INCREMENT TEMP_ARRAY PTR
		B CopyLeft ;CONTUNIE LOOP
		
CopyRight
		MOV R3, R9 ;LOAD RIGHT LIMIT FOR COMPARISON
		CMP R6, R3 ;COMPARE RIGHT PTR VS RIGHT LIMIT
		BGT WriteBack ;IF RIGHT PTR > RIGHT LIMIT, GO TO WRITE BACK FROM TEMP TO MAIN ARRAY
		
		LDR R1, [R6, #0] ;LOAD VALUE FROM RIGHT PTR
		STR R1, [R4, #0] ;STORE VALUE TO TEMP_ARRAY
		ADDS R6, R6, #4 ;INCREMENT RIGHT PTR
		ADDS R4, R4, #4 ;INCREMENT TEMP_ARRAY PTR
		B CopyRight ;CONTINUE LOOP
		
WriteBack 
		MOV R0, SP ;R0 HOLDS TEMP_ARRAY[0]
		MOV R1, R4 ;R1 HOLDS CURRENT TEMP_ARRAY PTR
		
		SUBS R2, R1, R0 ; R2= END-START (MEANS WRITTEN SIZE)
		MOV R3, R9 ;R3=ADDR OF LAST ELEMENT IN MAIN ARRAY
		SUBS R5, R2, #4 ;R5= SIZE-4
		SUBS R3, R3, R5 ;R3 HOLDS CALCULATED DESTINATION START ADDRESS
		MOV R5, R0 ;CURRENT TEMP_ARRAY PTR IN R5 (FROM)
		MOV R6, R3 ;CURRENT MAIN ARRAY PTR IN R6 (TO)
		
ArrayCopy
		CMP R5, R1 ;CHECK SOURCE PTR FROM TEMP_ARRAY IS REACHED CURRENT TEMP_ARRAY PTR
		BGE FinishMerge ;IF YES, COPY FINISHED (STOP CONDITION)
		
		LDR R0, [R5, #0] ;LOAD SORTED VALUE FROM TEMP_ARRAY
		STR R0, [R6, #0] ;STORE SORTED VALUE TO MAIN ARRAY
		
		ADDS R5, R5, #4 ;INCREMENT CURRENT TEMP_ARRAY PTR
		ADDS R6, R6, #4 ;INCREMENT CURRENT MAIN ARRAY PTR
		B ArrayCopy ;REPEAT
		
FinishMerge 
		ADD SP, SP, #32 ;DELETE TEMP_ARRAY
		POP {R4, R5} ;POP SAVED VALUES INTO R4, R5
		MOV R8, R4 ;RESTORE PRESERVED R8
		MOV R9, R5 ;RESTORE PRESERVED R9
		
		POP {R4-R7, PC} ;RESTORE REGISTERS AND RETURN WITH PC
		ENDP
		
		
		
        END
