	AREA    MergeSort_M0, CODE, READONLY
        THUMB
        ENTRY
        EXPORT  main
        EXPORT  my_MergeSort
        EXPORT  my_Merge

main	PROC
		;LOAD UNSORTED ARRAY ELEMENTS TO REGISTERS
		MOVS R0, #38
		MOVS R1, #27
		MOVS R2, #43
		MOVS R3, #10
		MOVS R4, #55
		
		PUSH {R0-R4} ;PUSH ARRAY TO STACK (LOWEST R0, HIGHEST R4) SP HOLDS ARR[0] 
		
		MOV R0, SP ;ADDRESS OF ARRAY(SP) MOVES R0
		MOVS R1, #0 ;LEFT INDEX
		MOVS R2, #4 ;RIGHT INDEX
		
		BL my_MergeSort ;RECURSIVE CALL MERGESORT FUNC.
		
		POP {R0-R4} ;RESTORE SORTED VALUES INTO R0-R4
						
stop    B       stop ; put breakpoint here to work
        ENDP

my_MergeSort PROC
		PUSH {R3-R7, LR} ;SAVE LR AND REGISTERS ON STACK
		
		;If(LEFT >=RIGHT)
		CMP R1,R2 
		BGE SortEnd ;IF BASE CASE SATISFIED, RETURN
		
		; MID = (LEFT+RIGHT) / 2
		ADDS R3, R1, R2 ; R3= R1+R2
		LSRS R3, R3, #1 ; R3=R3/2. NOW R3 HOLDS MID
		
		MOV R4, R1 ; SAVE LEFT TO R4
		MOV R5, R2 ;SAVE RIGHT TO R5
		MOV R6, R3 ;SAVE MID TO R6
		
		MOV R2, R3 ; SET RIGHT = MID
		BL my_MergeSort ;RECURSIVE CALL FOR LEFT PART
		
		MOV R1, R6 ;STORE MID TO R1
		ADDS R1, R1, #1 ;LEFT = MID+1
		MOV R2, R5 ;STORE RIGHT
		BL my_MergeSort ;RECURSIVE CALL FOR RIGHT PART
		
		MOV R1, R4 ;RESTORE LEFT
		MOV R2, R6 ;RESTORE MID
		MOV R3, R5;RESTORE RIGHT
		BL my_Merge ;CALL MERGE FUNC
		
SortEnd 
		POP {R3-R7, PC} ;RESTORE REGS AND RETURN 
		ENDP
		

my_Merge PROC
		PUSH {R4-R7, LR} ;SAVE CONTEXT
		MOV R4, R8 ;MOVE R8 TO R4
		MOV R5, R9  ;MOVE R9 TO R5
		PUSH {R4,R5} ; PUSH ORIGINAL R8,R9 TO STACK
		SUB SP, SP, #20 ;MOVE SP DOWN TO ALLOCATE 20 BYTE AREA(5 ELEMENT)
		MOV R4, SP ;R4 HOLDS TEMP_ARRAY[0]
		
		;COPY ARRAY TO TEMP_ARRAY
		MOV R5, R1 ;i=LEFT

CopyLoop
		CMP R5, R3 ; COMPARE i WITH RIHGT
		BGT MergeInit ; IF i > RIGHT, STOP COPY
		
		;LOAD FROM ARRAY[i]
		LSLS R6, R5, #2 ; R6= i*4 (BYTE OFFSET)
		ADD R6, R6, R0 ;R6= BASE + OFFSET
		LDR R7, [R6, #0] ;R7 = ARRAY[i]
		;STORE TO TEMP_ARRAY[i]
		LSLS R6, R5, #2 ; R6 = i*4
		ADD R6, R6, R4 ;R6 =TEMP_BASE + OFFSET
		STR R7, [R6, #0] ; TEMP_ARRAY[i] = ARRAY[i]
	
		ADDS R5, R5, #1 ; i++
		B CopyLoop ;REPEAT LOOP
	
MergeInit
		MOV R8, R2 ;R8 = MID
		MOV R9, R3 ;R9 = RIGHT
		
		MOV R5, R1 ;R5 =i(LEFT)
		MOV R6, R8 ;R6 = MID
		ADDS R6, R6, #1 ; R6 = J (MID +1)
		MOV R7, R1 ;R7 = k (LEFT)
	
MergeLoop
		;CHEHCK i >MID
		MOV R2, R8 ;COPY MID TO R2 FOR COMPARISON
		CMP R5, R2 ;COMPARE i VS MID
		BGT CopyRemaining_j ; IF LEFT PART EXHAUSTED, COPY REST OF RIGHT PART
		
		;CHECK j> RIGHT
		MOV R2, R9 ; COPY RIGHT TO LOW REG FOR COMPARISON
		CMP R6, R2 ; COMPARE j VS RIGHT
		BGT CopyRemaining_i ;IF RIGHT PART EXHAUSTED, COPY REST OF LEFT
		
		;COPARE TEMP_ARRAY[i] AND TEMP_ARRAY[j]
		;LOAD TEMP_ARRAY[i] INTO R1
		LSLS R2, R5, #2 ;OFFSET FOR i
		ADD R2, R2, R4 ; ADDR. OF TEMP_ARRAY[i]
		LDR R1, [R2,#0] ;VAL1 = TEMP_ARRAY[i]
		;LOAD TEMP_ARRAY[j] INTO R2
		LSLS R3, R6, #2 ;OFFSET FOR j
		ADD R3, R3, R4 ;ADDR. OF TEMP_ARRAY[J]
		LDR R2, [R3, #0] ;VAL2 = TEMP_ARRAY[J]
		
		
		CMP R1, R2 ;COMPARE TEMP_ARRAY[I] AND TEMP_ARRAY[J]
		BLE TakeLeft ;IF TEMP_ARRAY[i] <= TEMP_ARRAY[j], TAKE LEFT
		
		;ELSE TAKE RIGHT (TEMP[j])
		LSLS R3, R7, #2 ;OFFSET FOR k
		ADD R3, R3, R0 ;ADDR. OF ARRAY[k]
		STR R2, [R3,#0] ;ARRAY[k]= TEMP_ARRAY[j]
		ADDS R6, R6, #1 ;j++
		B NextIteration
		
TakeLeft
		;TEMP_ARRAY[i]
		LSLS R3, R7, #2 ;OFFSET FOR k
		ADD R3, R3, R0 ;ADDR OF ARRAY[k]
		STR R1, [R3, #0] ;ARRAY[k] = TEMP_ARRAY[i]
		ADDS R5, R5, #1 ; i++
	
NextIteration
		ADDS R7, R7, #1 ;k++
		B MergeLoop ; CONTINUE MergeLoop
		
CopyRemaining_i
		MOV R2, R8 ; MOVE MID TO LOW REG
		CMP R5, R2 ; COMPARE i>MID
		BGT CleanStack ;IF DONE, FINISH
		
		;ARRAY[k] = TEMP_ARRAY[i]
		LSLS R2, R5, #2 ; I*4
		ADD R2, R2, R4 ;ADDR ARRAY[i]
		LDR R1, [R2, #0] ;LOAD TEMP_ARRAY[i]
		LSLS R2, R7, #2 ;K*4
		ADD R2, R2, R0 ; ADDR ARRAY[k]
		STR R1, [R2, #0] ;STORE TO ARRAY[K]
		
		ADDS R5, R5, #1 ; i++
		ADDS R7, R7, #1 ;k++
		B CopyRemaining_i
		
CopyRemaining_j
		MOV R2, R9 ;MOVE RIGHT TO LOW REG
		CMP R6, R2 ;CHECK j> RIGHY
		BGT CleanStack ;IF DONE, FISISH
		
		LSLS R2, R6, #2 ; J*4
		ADD R2, R2, R4 ;ADDR ARRAY[k]
		LDR R1, [R2, #0]; LOAD VAL
		LSLS R2, R7, #2 ; K*4
		ADD R2, R2, R0 ;ADDR TEMP_ARRAY[j]
		STR R1, [R2, #0] ;STORE TO ARRAY[K]
		
		ADDS R6, R6, #1 ; j++
		ADDS R7, R7, #1 ;k++
		B CopyRemaining_j	
		
	
CleanStack
		ADD SP, SP, #20 ;DEALLOCATE TEMP_ARRAY
		POP {R4, R5} ; POP OLD R8, R9 INTO LOW REGS
		MOV R8, R4 ;RESTORE R8
		MOV R9, R5 ;RESTORE R9
		POP {R4-R7, PC} ;RESTORE REGS AND RETURN
		
		ENDP
		
	
        END